# Python科学计算基础

## 1.1 numpy库入门

``NumPy`` 扩展库  定义了由同类型的元素组成的多维数组``ndarray``及其常用运算，``ndarray`` 是科学计算中最常用的数据类型。NumPy 数组相对列表的优势是运算速度更快和占用内存更少。``ndarray``是一个类，它的别名是``array``。它的主要属性包括``ndim``(维数)、``shape``(形状，即由每个维度的长度构成的元组) 、``size``(元素数量) 和``dtype``(元素类型：可以是 Python 的内置类型，也可以是 NumPy
定义的类型，例如 numpy.int32、numpy.int16 和 numpy.float64 等)。

### 1.1.1 ``ndarry``对象

#### - 数组的创建及属性

+ 数组的创建使用``array()``函数，创建过程中向函数传递序列对象，如果传递多层嵌套序列则创建多维数组
  
  ```python
  a=np.array([1,2,3,4])
  b=np.array((1,2,3,4))
  c=np.array([[1,2,3,4],[4,5,6,7],[7,8,9,0]])
  ```

+ 数组的形状可以通过``shape``(描述数组各个轴的长度的元组)属性获得；同时还可以通过修改数组的``shape``,在保持数组元素个数不变的情况下改变数组每个轴的长度(不是转置);当设置``shape``中某个轴的元素个数为-1时，将自动计算此轴的长度
  
  ```python
  --snip--
  print(a.shape,b.shape,c.shape) # (4,) (4,) (3,4)
  c.shape=4,3
  print(c)
  c.shape=2,-1
  print(c)
  """
  (4,) (4,) (3, 4)
  [[1 2 3]
   [4 4 5]
   [6 7 7]
   [8 9 0]]
  [[1 2 3 4 4 5]
   [6 7 7 8 9 0]]
  """
  ```

+ 数组的``reshape()``方法可以返回新的指定形状的数组，且新数组与原数组共享存储空间，同步变化

+ 数组的元素类型可以通过``detype``属性获得，也可以通过``dtype``参数在创建数组吋指定元素类型(在需要指定``dtype``参数时，也可以传递字符串来表示元素的数值类型。``NumPy``中的每个数值类型都有几种字符串表示方式，字符串和类型之间的对应关系都存储在``typeDict``字典中),使用``astype()``方法可以对数组的元素类型进行转换
  
  ```python
  --snip--
  
  print(c.dtype)
  
  e=np.array([1,2,3,4],dtype=float)
  
  f=e.astype(np.int32)
  
  print(e.dtype,f.dtype)
  
  print(e,f)
  
  """
  
  int32
  
  float64 int32
  
  [1. 2. 3. 4.] [1 2 3 4]
  
  """
  ```

+ ``NumPy``有自己的数据类型，可以通过其数据类型建立对象，``NumPy``的数值对象的运算速度比Python的内置类型的运算速度慢很多，如果程序中需要大量地对单个数值运算，应当尽量避免使用``NumPy``的数值对象
  
  ```python
  import numpy as np 
  import time 
  a = 3.14 
  b = np.float64(a) 
  print(a, b) 
  starttime = time.time() 
  print(pow(a * 5, 55)) 
  endtime = time.time() 
  print(endtime - starttime) 
  starttime = time.time() 
  print(pow(b * 5, 55)) 
  endtime = time.time() 
  print(endtime - starttime) 
  """ 
  3.14159 3.14159 
  6.117487080542922e+65 
  0.0009829998016357422 
  6.117487080542922e+65 
  0.0 
  """ 
  ```

#### - 自动生成数组

+ ``arange()``函数通过指定开始值、终值和步长来创建表示等差数列的一维数组，所得到的结果中不包含终值

+ ``linspace()``通过指定幵始值、终值和元素个数来创建表示等差数列的一维数组，可以通过``endpoint``参数指定是否包含终值，默认值为``True``(包含终值)

+ ``logspace()``可以通过指定初始值、终值、元素个数创建等比数列，参数``base``(默认为10)和``endpoint``分别指定底数和是否包含终值 

+ ``zeros()``、``ones()``、``empty()``、``full()``可以创建指定形状和类型的数组。其中``empty()``只分配数组所使用的内存，不对数组元素进行初始化操作；``zeros()``将数组元素初始化为0, ``ones()``将数组元素初始化为1；``full()``将元素初始化为指定的值
  
  ```python
  print(np.arange(1, 10, 1)) 
  print(np.linspace(1, 10, 10, endpoint=True)) 
  print(np.linspace(1, 10, 10, endpoint=False)) 
  print(np.logspace(1, 5, 5, base=3, endpoint=True)) 
  print(np.zeros((2, 3), np.float32)) 
  print(np.ones((2, 3), np.float32)) 
  print(np.empty((2, 3), np.float32)) 
  print(np.full((2, 3), 1)) 
  """ 
  [1 2 3 4 5 6 7 8 9] 
  [ 1. 2. 3. 4. 5. 6. 7. 8. 9. 10.] 
  [1. 1.9 2.8 3.7 4.6 5.5 6.4 7.3 8.2 9.1] 
  [ 3. 9. 27. 81. 243.] 
  [[0. 0. 0.] [0. 0. 0.]] 
  [[1. 1. 1.] [1. 1. 1.]] 
  [[1. 1. 1.] [1. 1. 1.]] 
  [[1 1 1] [1 1 1]]
  """
  ```

+ ``zeros_like()``、``ones_like()``、``empty_like()``、``full_like()``等函数创建与参数数组的形状和类型相同的数组，因此``zeroslike(a)``和 ``zeros(a.shape，a.dtype)``的效果相同

+ ``frombuffer()``、``fromstring()``、``fromfile()``等函数可以从字节序列或文件创建数组，此时数组内的元素则按照元素类型有所不同：Python的字符串是一个字节序列，每个字符占一个字节，因此如果从字符串创建一个8位的整数数组，所得到的数组正好就是字符串中每个字符的ASCII编码([字符、位关系详见该文档](https://blog.csdn.net/qq_41675254/article/details/86481615))；如果从字符串创建16位的整数数组，那么两个相邻的字节就表示一个整数，且16位的整数是以低位字节在前的方式保存在内存中的([关于位和大小端的概念见该文档](https://zhuanlan.zhihu.com/p/510962688))；``fromstring()``会对字符串的字节序列进行复制，而使用``frombuffer()``创建的数组与原始字符串共享内存。由于字符串是只读的，因此无法修改所创建的数组的内容
  
  ```python
  a = np.fromstring(s, dtype=np.int8) 
  b = np.fromstring(s, dtype=np.int16) 
  c = np.fromstring(s, dtype=np.float64) 
  print(a,b,c) 
  """ [ 97 98 99 100 101 102 103 104] 
  [25185 25699 26213 26727] 
  [8.54088322e+194] 
  """
  ```

+ ``fromfunction()``通过函数返回值创建数组，其第一个参数是计算每个数组元素的函数，第二个参数指定数组的形状。它支持多维数组，第二个参数必须是一个序列，在调用函数时并没有``shape``的各个坐标迭代多次调用函数，**实际上只调用了一次函数**([关于传入数组问题详见该文章](https://www.zhihu.com/question/33561391))
  
  ```python
  def fun_1(i, j):
      return (i + 1) * (j + 1)
  
  a = np.fromfunction(fun_1, (9, 9))
  print(a)
  
  """
  [[ 1.  2.  3.  4.  5.  6.  7.  8.  9.]
   [ 2.  4.  6.  8. 10. 12. 14. 16. 18.]
   [ 3.  6.  9. 12. 15. 18. 21. 24. 27.]
   [ 4.  8. 12. 16. 20. 24. 28. 32. 36.]
   [ 5. 10. 15. 20. 25. 30. 35. 40. 45.]
   [ 6. 12. 18. 24. 30. 36. 42. 48. 54.]
   [ 7. 14. 21. 28. 35. 42. 49. 56. 63.]
   [ 8. 16. 24. 32. 40. 48. 56. 64. 72.]
   [ 9. 18. 27. 36. 45. 54. 63. 72. 81.]]
  """
  ```

#### - 数组元素存取

+ ``NumPy``数组的简单存取与列表相似，可以使用下标存取、修改和切片；切片使用``a[a1:a2:a3]``语言，其中``a1`` 表示开始下标，``a2``表示结束下标(切片时不包括) ，``a3``表示步长；下标可负，表示从末尾开始技术；步长可负，表示数组首尾颠倒；省略切片的开始下标和结束下标且步长为-1 ,可使整个数组头尾颠倒；和列表不同的是，通过切片获取的新的数组是原始数组的一个视图。它与原始数组共享同一块数椐存储空间 ，修改其中一个会修改另一个
  
  ```python
  a = np.array([0, 1, 2, 3, 4, 5, 6])
  print(a[2])
  print(a[0:3])
  print(a[:5])
  print(a[:-2])
  print(a[1:5:2])
  print(a[::-1])
  a[2:4] = 3, 4
  print(a)
  b = a[2:4]
  print(b)
  b[0:2] = 2, 3
  print(a, b)
  """
  2
  [0 1 2]
  [0 1 2 3 4]
  [0 1 2 3 4]
  [1 3]
  [6 5 4 3 2 1 0]
  [0 1 3 4 4 5 6]
  [3 4]
  [0 1 2 3 4 5 6] [2 3]
  """
  ```

+ ``NumPy``可以使用整数列表对数组元素进行存取，此时将使用列表中的每个元素(可为负)作为下标。使用列表作为下标得到的数组不和原始数组共享数据，同样具有下标法的方法。

+ ``NumPy``也可以使用整数数组作为数组下标，得到形状和下标数组相同的新数组，新数组的每个元素都是用下标数组中对应位置的值作为下标从原数组获得的值。当下标数组是一维数组时，结果和用列表作为下标的结果相同；当下标是多维数组时，得到的也是多维数组
  
  ```python
  a = np.array([0, 1, 2, 3, 4, 5, 6])
  b = a[[1, 2, 3, 4]]
  print(b)
  a[[0, 1, 2]] = 1, 2, 3
  c = a[np.array([1, 1, 3, 2, 4])]
  print(c)
  d = a[np.array([[1, 2, 3], [2, 3, 4]])]
  print(d)
  """
  [1 2 3 4]
  [2 2 3 3 4]
  [[2 3 3]
   [3 3 4]]
  """
  ```

+ ``NumPy``可以使用布尔数组作为下标存取和修改数组中的元素，此时获得原数组中与布尔数组中``True``对应的元素；使用布尔数组作为下标获得的数组不和原始数组共享数据内存，注意这种方式在``NumPy 1.10``之前版本只对应于布尔数组，不能使用布尔列表，如果是布尔列表，就把``True``当作1, 把``False``当作0 , 按照整数序列方式获取元素，在``NumPy 1.10``之后布尔列表与布尔数组输出相同
  
  ```python
  a = np.array([0, 1, 2])
  
  print(a[np.array([True, True, False])])
  c = a[[True, True, False]]
  print(c)
  
  b = np.logspace(1, 10, 5, base=3)
  print(b[b > 3.5])
  
  """
  [0 1]
  [0 1]
  [3.55339983e+01 4.20888346e+02 4.98528193e+03 5.90490000e+04]
  """
  ```

#### - 多维数组

+ 多维数组的存取、切片、修改和一维数组类似，因为多维数组有多个轴，所以它的下标需要用多个值来表示，``NumPy``采用元组作为数组的下标，元组中的每个元素和数组的每个轴对应；多维数组的切片同样采用下标法，与一位数组方法相同，如果下标元组中只包含整数和切片，那么得到的数组和原始数组共享数据，它是原数组的视图
  
  ```python
  a = np.arange(0, 60, 10).reshape(-1, 1) + np.arange(0, 6)
  print(a)
  print(a[1:3, 2:5])
  print(a[::2, 2:3])
  """
  [[ 0  1  2  3  4  5]
   [10 11 12 13 14 15]
   [20 21 22 23 24 25]
   [30 31 32 33 34 35]
   [40 41 42 43 44 45]
   [50 51 52 53 54 55]]
  [[12 13 14]
   [22 23 24]]
  [[ 2]
   [22]
   [42]]
  """
  ```

+ 因为数组的下标是一个元组，所以我们可以将下标元组保存起来，用同一个元组存取多个数组，创建这样的数组时使用切片(slice)对象或``s_``对象。``slice()``有三个参数，分别为开始值、结束值和间隔步长，当这些值需要省略时可以使用``None``；``s_``是``NumPy``提供的一个对象，用来创建数组下标
  
  ```python
  a = np.arange(0, 60, 10).reshape(-1, 1) + np.arange(0, 6)
  idx_1 = slice(None, None, 2), slice(2, None)
  print(a[idx_1])
  idx_2=np.s_[::2, 2:]
  print(a[idx_2])
  
  """
  [[ 2  3  4  5]
   [22 23 24 25]
   [42 43 44 45]]
  [[ 2  3  4  5]
   [22 23 24 25]
   [42 43 44 45]]
  """
  ```
  
  <img title="" src="file:///C:/Users/jiani/Pictures/Typedown/ab88be08-40d7-4e58-a5d8-a5bdc6609594.png" alt="ab88be08-40d7-4e58-a5d8-a5bdc6609594" data-align="center" style="zoom:100%;">

+ 在多维数组的下标元组中，也可以使用整数元组或列表、整数数组和布尔数组，当下标中使用这些对象时，所获得的数椐是原始数据的副木，因此修改结果数组不会改变原始数组。
  
  ```python
  a = np.arange(0, 60, 10).reshape(-1, 1) + np.arange(0, 6)
  print(a[[0, 1, 2, 3], (2, 3, 4, 5)])
  print(a[3:, (0, 2, 5)])
  mask1 = np.array([1, 0, 1, 0, 0, 1], dtype=np.bool_)
  print(a[mask1, 2])
  mask2 = np.array([1, 0, 1, 0, 0, 1])
  print(a[mask2, 2])
  x = np.array([[0, 1], [-1, 3]])
  y = np.array([[1, 2], [2, -3]])
  print(a[x, y])
  print(a[x])
  """
  [ 2 13 24 35]
  [[30 32 35]
   [40 42 45]
   [50 52 55]]
  [ 2 22 52]
  [12  2 12  2  2 12]
  [[ 1 12]
   [52 33]]
  [[[ 0  1  2  3  4  5]
    [10 11 12 13 14 15]]
  
   [[50 51 52 53 54 55]
    [30 31 32 33 34 35]]]
  """type)
  
  
  ```

#### - 结构数组

类似于C语言可以通过``struct``关键字定义结构类型，``NumPy``也提供了结构数组，其定义方式如下

```python
persontype = np.dtype(
    {'names': ['name', 'age', 'weight'], 'formats': ['S30', 'i', 'f']}, align=True
)

a = np.array([('Petre', 32, 60), ("Lee", 20, 61)], dtype=persontype)

print(a.dtype)
print(a)

"""
{'names': ['name', 'age', 'weight'], 'formats': ['S30', '<i4', '<f4'], 'offsets': [0, 32, 36], 'itemsize': 40, 'aligned': True}
[(b'Petre', 32, 60.) (b'Lee', 20, 61.)]
"""
```

首先创建一个``dtype``对象``persontype``，它的参数是一个描述结构类型的各个字段的字典。字典有两个键：``names``和``formats``， 每个键对应的值都是一个列表。``name``定义结构中每个字段的名称，``formats``定义每个字段的类型：

+ ``'S30'``:长度为30个字节的字符串类型，由于结构中的每个元素的大小必须同定，因此需要指定字符串的长度。

+ ``'i'``:32位的整数类型，相当于``np.int32``

+ ``'f'``:32位的单精度浮点数类型，相当于``np.float32``


